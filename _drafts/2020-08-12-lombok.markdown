---
layout:     post
title:      "Java Libraries - lombok - introduction"
date:       2020-08-12 15:47:00 +0200
modified:   2020-08-12 15:47:00 +0200
categories: libraries
keywords:   java, libraries, lombok
video:      ""
abstract:   "What is lombok, and what can it do?"
author:     "Rainer Jung"
---
Lombok - What can it do?
========================

If you work a lot with [Beans](https://de.wikipedia.org/wiki/JavaBeans), you probably hate writing them. There's so much boilerplate that needs to be done, just to provide the main methods of the Bean. Adding new properties always means, don't forget to update the `equals`-, `hashCode`- and `toString`-methods.  

Lombok helps a lot, but it has other cool features, not only for Beans.

I will not explain how to install it.  
Follow the instructions from the [setup description](https://projectlombok.org/setup/overview) for your usage.  

I will also not talk about experimental features (at the time of recording).

What is lombok doing?
---------------------

Lombok is not a simple library. It's an [annotation processor](https://en.wikipedia.org/wiki/Java_annotation#Processing).

This means that it processes annotations during compile time as compiler-plugin. It creates boilerplate code for us, so that we do not need to care about it. Only if we need something special, we write it our own.

For all code generated by lombock, there's the rule, if we write the method ourselfs, it will not be overwritten by lombok.

Getter / Setter
---------------

To experiment, we create a simple Bean-class and get more and more annotations.

We start with a simple bean like a `Profile`. The `Profile` has a property name.

The property itself is private and we want to have a getter for the name, so we can annotate the property with `@Getter`.  
The outline of `Profile` now has a public `getName()` method.

```java
public class Profile {
  @Getter
  private String name;
}
```

Like the `@Getter`, there's the `@Setter` which will create a setter for the property.

The name of a boolean getter has a different name.  
If we add a boolean `active` flag, the getter is called `isActive` instead of `getActive`.

The setter will still be called `setActive`.

```java
public class Profile {
  @Getter
  @Setter
  private String name;
  @Getter
  @Setter
  private boolean active;
}
```

Putting the annotation to every property is pretty messy. In most cases, all properties have a getter or setter, so we can put the annotation to the class.

We can also combine annotations at class level and property level. For example we have a getter for all properties, but only a setter for the name.

```java
@Getter
public class Profile {
  @Setter
  private String name;
  private boolean active;
}
```

Now we add an additional property email.

But we don't want the getter for this property to be public.  
The `@Getter` annotation can set the `AccessLevel`.

It can be set to `MODULE`, `NONE` (which means that there's no getter), `PACKAGE` (which means package private), `PRIVATE` and `PROTECTED`.  
We use `PROTECTED`.  

If we check for the outline of the class, we can see that the `getEmail`-method is protected.

```java
@Getter
public class Profile {
  @Setter
  private String name;
  @Getter(AccessLevel.PROTECTED)
  private String email;
  private boolean active;
}
```

If we create a getter or setter that would be generated by lombok, the method will not me overwritten or modified.

Equals and HashCode
-------------------

To be able to compare Beans and to use them in `HashMap`s, they need to have the `equals`- and `hashCode`-method implemented.

By adding the annotation `@EqualsAndHashCode`, we have both methods generated.
 
Both methods will use all properties available to compare other Profiles or to generate the `hashCode`.

Properties can be ignored if needed.  
If we want the active flag not to be part of the `equals`- and `hashCode`-methods, I can annotate the property with
`@EqualsAndHashCode.Exclude`.  

Now we want to go the other way and only include the properties that are explicitly annotated with the `@EqualsAndHashCode.Include` annotation.  
The `@EqualsAndHashCode` has the property `onlyExplicitlyIncluded`, which is `false` by default.  
So we set it to `true`.  

Now, only properties that are annotated with `@EqualsAndHashCode.Include` are considered by the `equals`- and `hashCode`-method.

```java
@EqualsAndHashCode
@Getter
public class Profile {
  @Setter
  private String name;
  @Getter(AccessLevel.PROTECTED)
  private String email;
  @EqualsAndHashCode.Exclude
  private boolean active;
}
```

There are some special cases.

If our class extends another class, we need to think about if we want to include the parents properties.

By default, the generated methods ignore the parent and all properties.

`@EqualsAndHashCode` has the property `callSuper` that can be set to `true`, now the parents properties are included.

By default, the getters are used from the `equals`- and `hashCode`-method to retrieve all values from the bean.  
If we do not want the getters to be used, we can also set the `doNotUseGetters`.  
Now the properties are used directly.

Constructor
-----------

We now have a nice Bean, but we cannot yet use it, because there's no constructor available.  
Of course, lombok has some annotations as well.

The simpliest one is the `@NoArgsConstructor`. It creates a simple `Profile()` constructor without any parameters.

```java
@EqualsAndHashCode
@Getter
@NoArgsConstructor
public class Profile {
  @Setter
  private String name;
  @Getter(AccessLevel.PROTECTED)
  private String email;
  @EqualsAndHashCode.Exclude
  private boolean active;
}
```

To get some a bean with values, there's also the `@AllArgsConstructor`.  
With this annotation, a constructor is created with all available properties in the order of their definition.

There's one additional constructor annotation. If the class has `final` properties, there's the `@RequiredArgsConstructor`.

We'll later talk about the annotation `@NonNull` in another video.  
Properties that are annotated with `@NonNull` are verified by generated code to not be `null`.  
`@RequiredArgsConstructor` interprets them as required arguments, they will be included with the constructor.

If there are no final properties, the `@RequiredArgsConstructor` clashes with the `@NoArgsConstructor`.

If there's a `final` property (or a property annotated with `@NonNull`), the `@NoArgsConstructor` cannot be used.  
We can still force the `@NoArgsConstructor` to be created by adding the property `force`, which would initialize all final properties as `0`, `false` or `null`.

```java
@EqualsAndHashCode
@Getter
@AllArgsConstructor
@RequiredArgsConstructor
public class Profile {
  @Setter
  private String name;
  @Getter(AccessLevel.PROTECTED)
  final private String email;
  @EqualsAndHashCode.Exclude
  private boolean active;
}
```

There are some other specialities of the construcrors.  
They can all be made private and be exposed by a static method my adding a property `staticName` to the annotation.

By adding `staticName = "of"` to the `@RequiredArgsConstructor`, the constructor with the email is private and is called by the static method `of` with the `email` as parameter.

Like the getter and setter methods, if one of the methods already exist, this method will not be generated or changed.

toString
--------

We now have a nice class, but if we do a `System.out.println(profile)`, we get a result (like `Profile@bdaa8fd7`) that does not contain real information.

So we can add the annotation `@ToString`, and can directly see the properties of the profile (`Profile(name=null, email=me@example.com, active=false)`.

```java
@EqualsAndHashCode
@Getter
@ToString
@AllArgsConstructor
@RequiredArgsConstructor
public class Profile {
  @Setter
  private String name;
  @Getter(AccessLevel.PROTECTED)
  final private String email;
  @EqualsAndHashCode.Exclude
  private boolean active;
}
```

Perhaps, we do not want all the properties to be included in the `toString`-method.  
Like for the `@EqualsAndHashCode` annotation, we can annotate properties to be excluded with `@ToString.Exclude`.

There is a property `onlyExplicitlyIncluded` and a `@ToString.Include` to only include explicitely included properties.  

We can change the name of the property by adding a `name` with `@ToString.Include` to the property.  
We can also set a order by setting the `rank`.

A special case is inheritance.  
By default, nothing from the parent class is used in the `toString`-method unless we define `callSuper` to be `true` for the `@ToString` annotation.

We could not want to have the getters be called, so you can also set `doNotUseGetters` to `true`.

If there's a method already (name `toString`, no parameters), nothing will be overwritten or modified.

Shortcut
--------

Okay, so, that's already quite some annotations we've put on this class.  
It's definitively better than having all methods and constructors generated, but a standard Bean just has all getters, setters, `equalTo` and `hashCode`.  

There's a shortcut annotation called @Data that combines the annotations `@ToString`, `@EqualsAndHashCode`, `@Getter` / `@Setter` and `@RequiredArgsConstructor`.  

Once there's another constructor annotation, only the one(s) defined will be available.

```java
@Data
public class Profile {
  @Setter
  private String name;
  @Getter(AccessLevel.PROTECTED)
  @ToString.Exclude
  final private String email;
  @EqualsAndHashCode.Exclude
  @ToString.Include()
  private boolean active;
}
```

More to come
------------

This is the default usage of lombok, there's more stuff, but it will be part of
another video.
